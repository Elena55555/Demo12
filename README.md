## Практическое задание 
Создаем объект
И так, чтобы что-то тестировать, нам для начала нужен объект тестирования. Перед нами стоит задача.
Нам нужен объект, который будет хранить информацию о Пользователе.
Id — нужно считать по порядку добавления нового пользователя.
Имя пользователя.
Его возраст.
Пол (male/female)
Нужно предусмотреть хранение списка пользователей.

Класс должен уметь.

Формировать список всех пользователей.
Формировать список пользователей по полу (MALE/FEMALE).
Возвращать количество пользователей в общем списке, и посчитать количество по признаку пола пользователя.
Посчитать общую сумму по возрасту пользователей, так же учесть по признаку пола.
Посчитать средний возраст, как общий так и по признаку пола.
И так, приступим к созданию объекта…

 

Для хранения данных о пользователе этого достаточно, посмотрим что там еще нужно по задаче.

Нам нужно как-то хранить всех пользователей, сделаем в нашем классе статическое поле allUsers, думаю нормально если это будет Map<Integer, User>

private static Map<Integer, User> allUsers;

Еще нам как-то нужно присваивать порядковый номер пользователям, создадим статическое поле счетчик, который при создании нового пользователя, будет присваивать порядковый Id пользователю.

private static int countId = 0;

Так, с полями вроде разобрались, напишем конструктор для нашего объекта, и гетеры для полей id, name, age, sex. C гетерами там ничего сложного нет, попросим помощи у IDEA, она никогда не откажет, а конструктор сделаем немного с хитростью. 

Конструктор будет уметь. Инициализировать поля, проверять есть ли такой объект в allUsers, если такого объекта нет, то увеличиваем наш счетчик countId++, и добавляем его в список всех пользователей. А так же инициализировать поле allUsers ели оно еще не было инициализировано.

Для удобства поиска одинаковых объектов, переопределим методы equals() и hashCode(), опять попросим помощи у любимой IDEA и будем сравнивать по полям name, age, sex. Плюс создадим приватный метод hasUser(), который будет проверять есть ли такой объект в списке.
 

 

 Реализовать логику требуемых методов. Так как логика в основном будет работать со статическими полями, методы тоже сделаем статическими, для объектов они не нужны.

Формировать список всех пользователей.
Формировать список пользователей по полу(MALE/FEMALE).
С пунктами a и b хорошо справится метод getAllUsers() который будет возвращать лист всех User, и перегруженный метод getAllUsers(Sex sex) он будет возвращать список, в зависимости от переданного параметра Sex.

 
Возвращать количество пользователей в общем списке, и посчитать количество по признаку пола пользователя.

 

Посчитать общую сумму по возрасту пользователей, так же учесть по признаку пола. Для этой задачи сделаем методы.

 
 

Посчитать средний возраст, как общий так и по признаку пола.
 
Отлично, требуемый объект и его поведение мы описали. Теперь можно переходить к JUnit, но для начала  -  как примерно будет выглядеть простой тест если мы его будет делать в main.

public static void main(String[] args) {
    new User("Евгений", 35, Sex.MALE);
    new User("Марина", 34, Sex.FEMALE);
    new User("Алина", 7, Sex.FEMALE);


    System.out.println("Все пользователи:");
    User.getAllUsers().forEach(System.out::println);
    System.out.println("Все пользователи: MALE");
    User.getAllUsers(Sex.MALE).forEach(System.out::println);
    System.out.println("Все пользователи: FEMALE");
    User.getAllUsers(Sex.FEMALE).forEach(System.out::println);
    System.out.println("================================================");
    System.out.println("       всех пользователей: " + User.getHowManyUsers());
    System.out.println("  всех пользователей MALE: " + User.getHowManyUsers(Sex.MALE));
    System.out.println("всех пользователей FEMALE: " + User.getHowManyUsers(Sex.FEMALE));
    System.out.println("================================================");
    System.out.println("       общий возраст всех пользователей: " + User.getAllAgeUsers());
    System.out.println("  общий возраст всех пользователей MALE: " + User.getAllAgeUsers(Sex.MALE));
    System.out.println("общий возраст всех пользователей FEMALE: " + User.getAllAgeUsers(Sex.FEMALE));
    System.out.println("================================================");
    System.out.println("       средний возраст всех пользователей: " + User.getAverageAgeOfAllUsers());
    System.out.println("  средний возраст всех пользователей MALE: " + User.getAverageAgeOfAllUsers(Sex.MALE));
    System.out.println("средний возраст всех пользователей FEMALE: " + User.getAverageAgeOfAllUsers(Sex.FEMALE));
    System.out.println("================================================");
}
Вывод в консоль получим примерно такой, а дальше сравниваем получили ли мы нормальную работу. Можно конечно углубиться, написать логику сравнения, и посмотреть, что скажет наше вычисление, при том что мы не будем уверены, что все смогли предусмотреть.
 
Запускаем тесты 
 Причины провала теста. Тут мы видим, что в инспектируемом списке больше пользователей чем в актуальном. Это и есть причина провала. А в main мы можем проверить так? JUnit : main = 1 : 0. Давайте посмотрим как будет выглядеть тест, если в нем будут полностью разные объекты, сделаем это так:

@Test
public void getAllUsers() {
    //создаем тестовые данные
    User user = new User("Евгений", 35, true);
    User user1 = new User("Марина", 34, false);
    User user2 = new User("Алина", 7, false);

    //создаем список expected и заполняем его данными нашего метода
    List<User> expected = User.getAllUsers();

    //создаем список actual в него помещаем данные для сравнения
    //то что мы предпологиаем метод должен вернуть
    List<User> actual = new ArrayList<>();
    actual.add(new User("User1", 1, false));
    actual.add(new User("User2", 2, false));
    actual.add(new User("User3", 3, false));

    //запускаем тест, в случае если список expected и actual не будут равны
    //тест будет провален, о результатах теста читаем в консоли
    Assert.assertEquals(expected, actual);
}

вот что будет в консоли:
JUnit part I - 8тут сразу видно что в сравниваемых списках разные пользователи, еще мы можем кликнуть на &ltClick to see difference> получим такое окно, где можно посмотреть подробно с какими данными у нас проблема. IDEA подсветит все поля в которых есть различия.
JUnit part I - 9main такое может? — нет. JUnit : main = 2 : 0

Ну что, пойдем дальше у нас еще куча методов, которые нужно покрыть тестами ), но подождите, а ведь будет не плохо, проверить, а не будет ли нам метод getAllUsers() возвращать null, ведь примерно так нас на задачах JavaRush ловит валидатор ). Сделаем это, делов то на три копейки …

@Test
public void getAllUsers_NO_NULL() {
    //добавим проверку на null
    List<User> expected = User.getAllUsers();
    Assert.assertNotNull(expected);
}

Да, да примерно так валидатор ловит наш  код на null.   Теперь запустим этот тест, и посмотрим, что он нам покажет. А покажет он ошибку,  и значит при вызове метода getAllUsers(),
мы обратимся к объекту, который еще не был инициализирован. 

СТАЛО:
private static Map<Integer, User> allUsers = new HashMap<>();

    public User(String name, int age, boolean isMale) {
        this.name = name;
        this.age = age;
        this.isMale = isMale;

        if (!hasUser()) {
            countId++;
            this.id = countId;
            allUsers.put(id, this);
        }
    }

    БЫЛО:
    public User(String name, int age, boolean isMale) {
    if (allUsers == null){
        allUsers = new HashMap<>();
    }

    this.name = name;
    this.age = age;
    this.isMale = isMale;

    if (!hasUser()){
        countId++;
        this.id = countId;
        allUsers.put(id, this);
    }
}
